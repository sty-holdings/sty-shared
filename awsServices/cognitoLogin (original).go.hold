// Package sty_shared
// Thank to https://github.com/alexrudd/cognito-srp where this code was forked.
package sty_shared

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"hash"
	"math/big"
	"strings"
	"time"

	awsCIP "github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
	ctv "github.com/sty-holdings/constant-type-vars-go/v2024"
	pi "github.com/sty-holdings/sty-shared/v2024/programInfo"
)

// NewCognitoLogin - creates a CognitoLogin object. If you have a clientSecret, we use a pointer
// so there is only one place in memory (Security).
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
func NewCognitoLogin2(
	username, password string,
	clientSecretPtr *string,
	getSecret bool,
	session AWSSession,
) (
	cognitoLogin *CognitoLogin,
	errorInfo pi.ErrorInfo,
) {

	if strings.Contains(session.STYConfig.UserPoolId, "_") == false {
		errorInfo = pi.NewErrorInfo(pi.ErrCognitoUserpoolIdInvalid, session.STYConfig.UserPoolId)
		return
	}

	cognitoLogin = &CognitoLogin{
		bigNPtr:         hexToBig(initN),
		clientId:        session.STYConfig.ClientId,
		clientPtr:       awsCIP.NewFromConfig(session.BaseConfig),
		clientSecretPtr: clientSecretPtr,
		getSecret:       getSecret,
		gPtr:            hexToBig(initG),
		kPtr:            hexToBig(hexHash("00" + initN + "0" + initG)),
		password:        password,
		username:        username,
		userPoolId:      session.STYConfig.UserPoolId,
		userPoolName:    strings.Split(session.STYConfig.UserPoolId, "_")[1],
	}
	// cognitoLogin.aPtr = cognitoLogin.generateRandomSmallA()
	// cognitoLogin.bigAPtr = cognitoLogin.calculateA()

	return
}

// GetUsername returns the configured Cognito user username
func (csrp *CognitoLogin) GetUsername2() string {
	return csrp.username
}

// GetUserPoolId returns the configured Cognito User Pool ID
func (csrp *CognitoLogin) GetUserPoolId2() string {
	return csrp.userPoolId
}

// GetUserPoolName returns the configured Cognito User Pool Name
func (csrp *CognitoLogin) GetUserPoolName2() string {
	return csrp.userPoolName
}

// GetAuthParams - returns the Auth Parameter map of values. If getSecret = true, then the
// client secret will be returned. If the client secret is missing, then authParams will be empty.
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
func (csrp *CognitoLogin) GetAuthParams2() (
	authParams map[string]string,
) {

	var (
		errorInfo pi.ErrorInfo
	)

	authParams = map[string]string{
		"USERNAME": csrp.username,
		"PASSWORD": csrp.password, // ??????????????
		"SRP_A":    bigToHex(csrp.bigAPtr),
	}

	if csrp.getSecret {
		if authParams["SECRET_HASH"], errorInfo = csrp.GetSecretHash(csrp.username); errorInfo.Error != nil {
			pi.PrintErrorInfo(errorInfo)
			return
		}
	}

	return
}

// GetSecretHash returns the secret hash string required to make certain
// Cognito Identity Provider API calls (if client is configured with a secret)
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
func (csrp *CognitoLogin) GetSecretHash2(username string) (
	clientSecretHash string,
	errorInfo pi.ErrorInfo,
) {

	var (
		tHmac hash.Hash
		tKey  []byte
		tMSG  string
	)

	if csrp.clientSecretPtr == nil {
		errorInfo = pi.NewErrorInfo(pi.ErrClientSecretMissing, ctv.VAL_EMPTY)
		return
	}

	tMSG = username + csrp.clientId
	tKey = []byte(*csrp.clientSecretPtr)
	tHmac = hmac.New(sha256.New, tKey)

	tHmac.Write([]byte(tMSG))

	clientSecretHash = base64.StdEncoding.EncodeToString(tHmac.Sum(nil))

	return
}

// PasswordVerifierChallenge - returns the ChallengeResponses map to be used
// inside the cognitoidentityprovider.RespondToAuthChallengeInput object which
// fulfils the PASSWORD_VERIFIER Cognito challenge
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
func (csrp *CognitoLogin) PasswordVerifierChallenge(
	challengeParams map[string]string,
	ts time.Time,
) (
	passwordVerifierChallengeParams map[string]string,
	errorInfo pi.ErrorInfo,
) {

	var (
		tHKDF             = csrp.getPasswordAuthenticationKey(challengeParams["SALT"], csrp.password, hexToBig(challengeParams["SRP_B"]), hexToBig(challengeParams["SALT"]))
		tInternalUsername = challengeParams["USERNAME"]
		tMSG              string
		tSecretBlockB64   = challengeParams["SECRET_BLOCK"]
		tSecretBlockBytes []byte
		tTimestamp        = ts.In(time.UTC).Format("Mon Jan 2 03:04:05 MST 2006")
		tUserId           = challengeParams["USER_ID_FOR_SRP"]
	)

	if tSecretBlockBytes, errorInfo.Error = base64.StdEncoding.DecodeString(tSecretBlockB64); errorInfo.Error != nil {
		errorInfo = pi.NewErrorInfo(pi.ErrCognitoUsernameMissing, ctv.VAL_EMPTY)
		return
	}

	tMSG = csrp.userPoolName + tUserId + string(tSecretBlockBytes) + tTimestamp
	hmacObj := hmac.New(sha256.New, tHKDF)
	hmacObj.Write([]byte(tMSG))
	signature := base64.StdEncoding.EncodeToString(hmacObj.Sum(nil))

	passwordVerifierChallengeParams = map[string]string{
		"TIMESTAMP":                   tTimestamp,
		"USERNAME":                    tInternalUsername,
		"PASSWORD_CLAIM_SECRET_BLOCK": tSecretBlockB64,
		"PASSWORD_CLAIM_SIGNATURE":    signature,
	}

	if csrp.getSecret {
		if passwordVerifierChallengeParams["SECRET_HASH"], errorInfo = csrp.GetSecretHash(csrp.username); errorInfo.Error != nil {
			pi.PrintErrorInfo(errorInfo)
			return
		}
	}

	return
}

func (csrp *CognitoLogin) getPasswordAuthenticationKey2(
	username, password string,
	bigB, salt *big.Int,
) []byte {
	var (
		userPass     = fmt.Sprintf("%s%s:%s", csrp.userPoolName, username, password)
		userPassHash = hashSha256([]byte(userPass))

		uVal      = calculateU(csrp.bigAPtr, bigB)
		xVal      = hexToBig(hexHash(padHex(salt.Text(16)) + userPassHash))
		gModPowXN = big.NewInt(0).Exp(csrp.gPtr, xVal, csrp.bigNPtr)
		intVal1   = big.NewInt(0).Sub(bigB, big.NewInt(0).Mul(csrp.kPtr, gModPowXN))
		intVal2   = big.NewInt(0).Add(csrp.aPtr, big.NewInt(0).Mul(uVal, xVal))
		sVal      = big.NewInt(0).Exp(intVal1, intVal2, csrp.bigNPtr)
	)

	return computeHKDF(padHex(sVal.Text(16)), padHex(bigToHex(uVal)))
}

// func hashSha256(buf []byte) string {
// 	a := sha256.New()
// 	a.Write(buf)
//
// 	return hex.EncodeToString(a.Sum(nil))
// }

// func bigToHex(val *big.Int) string {
// 	return val.Text(16)
// }

// func getRandom(n int) *big.Int {
// 	b := make([]byte, n)
// 	_, _ = rand.Read(b)
//
// 	return hexToBig(hex.EncodeToString(b))
// }

// padHex - pads a big.Int with leading zeros (replace if needed)
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
// func padHex(hexStr string) string {
// 	if len(hexStr)%2 == 1 {
// 		hexStr = fmt.Sprintf("0%s", hexStr)
// 	} else if strings.Contains("89ABCDEFabcdef", string(hexStr[0])) {
// 		hexStr = fmt.Sprintf("00%s", hexStr)
// 	}
//
// 	return hexStr
// }

// computeHKDF - uses the standard HKDF algorithm
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
// func computeHKDF(ikm, salt string) []byte {
// 	ikmb, _ := hex.DecodeString(ikm)
// 	saltb, _ := hex.DecodeString(salt)
//
// 	extractor := hmac.New(sha256.New, saltb)
// 	extractor.Write(ikmb)
// 	prk := extractor.Sum(nil)
// 	infoBitsUpdate := append([]byte(infoBits), byte(1))
// 	extractor = hmac.New(sha256.New, prk)
// 	extractor.Write(infoBitsUpdate)
// 	hmacHash := extractor.Sum(nil)
//
// 	return hmacHash[:16]
// }

// calculateU - creates the hash of A and B
//
//	Customer Messages: None
//	Errors: None
//	Verifications: None
// func calculateU(bigA, bigB *big.Int) *big.Int {
// 	return hexToBig(hexHash(padHex(bigA.Text(16)) + padHex(bigB.Text(16))))
// }
